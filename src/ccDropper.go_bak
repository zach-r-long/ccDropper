package main

import (
	v1 "../../minimega/phenix/types/version/v1"
	"../tmpl"
	"encoding/json"
	"fmt"
	"gopkg.in/yaml.v3"
	"log"
	"os"
	"path/filepath"
	"strings"
)

const NAME = "ccDropper"

type Host struct {
	Hostname string
	Cfg      AgentConfig `yaml:",inline"`
}

type AgentConfig struct {
	AgentPath string `yaml:"agent_path"`
	AutoStart bool   `yaml:"auto_start"`
	Agent     string `yaml:"agent"`
	AgentArgs string `yaml:"agent_args"`
}

type DropperConfig struct {
	Generic  AgentConfig 
	Specific []Host
}

func Name() string {
	return NAME
}

func agentPath(ext string, agent string, path string) string {
	dir, err := os.Open(path)
	if err != nil {
		log.Fatal("ccDropper: Error opening agent directory, check scenario \n"+"Path: "+path+"\n" ,err)
	} else {
		files, er := dir.Readdir(-1)
		dir.Close()
		if er != nil {
			log.Fatal(er)
		}
		for _, file := range files {
			if strings.Contains(file.Name(), agent) {
				if ext != "" && strings.HasSuffix(file.Name(), ext) {
					return filepath.Join(path, file.Name())
				}
				return filepath.Join(path, file.Name())
			}
		}
	}
	return ""
}

func injectCC(node *v1.Node, config DropperConfig, startupDir string) error {
	agentDst := "/minimega/"
	agentCfg := config.Generic
	ext := ""
	for _, host := range config.Specific {
		if host.Hostname == node.General.Hostname {
			agentCfg = host.Cfg
		}
	}

	switch node.Hardware.OSType {
	case v1.OSType_Windows:
		ext = "exe"

		var (
			startupFile = startupDir + "/" + node.General.Hostname + "-startup.ps1"
			schedFile   = startupDir + "/" + node.General.Hostname + "-scheduler.cmd"
		)

		a := &v1.Injection{
			Src: startupFile,
			Dst: agentDst + "startup.ps1",
		}
		b := &v1.Injection{
			Src: schedFile,
			Dst: "ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp/CommandAndControl.cmd",
		}

		node.Injections = append(node.Injections, a, b)

	case v1.OSType_Linux, v1.OSType_RHEL, v1.OSType_CentOS:
		ext = ""

		var (
			startupFile = startupDir + "/" + node.General.Hostname + "-startup.sh"
			schedFile   = startupDir + "/" + node.General.Hostname + "-startup.service"
		)
		a := &v1.Injection{
			Src:         startupFile,
			Dst:         agentDst + "startup.sh",
			Description: "",
		}
		b := &v1.Injection{
			Src:         schedFile,
			Dst:         "/etc/systemd/system/CommandAndControl.service",
			Description: "",
		}
		node.Injections = append(node.Injections, a, b)

	}
	//inject the actual agent
	a := &v1.Injection{
		Src:         agentPath(ext, agentCfg.Agent, agentCfg.AgentPath),
		Dst:         agentDst,
		Description: "",
	}
	node.Injections = append(node.Injections, a)
	return nil
}

func getVms(spec *v1.ExperimentSpec) []v1.Node {
	vms := spec.Topology.Nodes
	not_vms := spec.Topology.FindNodesWithLabels("hitl")
	var vmList []v1.Node
	if len(not_vms) > 0 {
		for _, vm := range vms {
			for _, not_vm := range not_vms {
				if vm.General.Hostname != not_vm.General.Hostname {
					vmList = append(vmList, *vm)
				}
			}
		}
		return vmList
	}
	for _, vm := range vms {
		vmList = append(vmList,*vm)
	}
	return vmList
}

func configure(spec *v1.ExperimentSpec, config DropperConfig, startupDir string) {
	vms := getVms(spec)
	for _, node := range vms {
		agentDst := "/minimega/"
		agentCfg := config.Generic
		ext := ""
		for _, host := range config.Specific {
			if host.Hostname == node.General.Hostname {
				agentCfg = host.Cfg
			}
		}

		switch node.Hardware.OSType {
		case v1.OSType_Windows:
			ext = "exe"

			var (
				startupFile = startupDir + "/" + node.General.Hostname + "-startup.ps1"
				schedFile   = startupDir + "/" + node.General.Hostname + "-scheduler.cmd"
			)

			a := &v1.Injection{
				Src: startupFile,
				Dst: agentDst + "startup.ps1",
			}
			b := &v1.Injection{
				Src: schedFile,
				Dst: "ProgramData/Microsoft/Windows/Start Menu/Programs/StartUp/CommandAndControl.cmd",
			}

			node.Injections = append(node.Injections, a, b)

		case v1.OSType_Linux, v1.OSType_RHEL, v1.OSType_CentOS:
			ext = ""

			var (
				startupFile = startupDir + "/" + node.General.Hostname + "-startup.sh"
				schedFile   = startupDir + "/" + node.General.Hostname + "-startup.service"
			)
			a := &v1.Injection{
				Src:         startupFile,
				Dst:         agentDst + "startup.sh",
				Description: "",
			}
			b := &v1.Injection{
				Src:         schedFile,
				Dst:         "/etc/systemd/system/CommandAndControl.service",
				Description: "",
			}
			node.Injections = append(node.Injections, a, b)

		}
		//inject the actual agent
		a := &v1.Injection{
			Src:         agentPath(ext, agentCfg.Agent, agentCfg.AgentPath),
			Dst:         agentDst,
			Description: "",
		}
		node.Injections = append(node.Injections, a)
	}
}

func start(spec *v1.ExperimentSpec, config DropperConfig, startupDir string) {
	vms := getVms(spec)
	for _, vm := range vms {
		agentCfg := config.Generic
		for _, host := range config.Specific {
			if host.Hostname == vm.General.Hostname {
				agentCfg = host.Cfg
			}
		}
		if vm.Type == "Router" {
			file := startupDir + "/" + vm.General.Hostname + "-startup.sh"
			if err := tmpl.CreateFileFromTemplate("linux_startup.tmpl", agentCfg, file); err != nil {
				log.Fatal("generating linux command and control startup script: ", err)
			}
			file = startupDir + "/" + vm.General.Hostname + "-startup.service"
			if err := tmpl.CreateFileFromTemplate("linux-service.tmpl", agentCfg, file); err != nil {
				log.Fatal("generating linux command and control service script: ", err)
			}

		} else if vm.Hardware.OSType == v1.OSType_Linux {
			file := startupDir + "/" + vm.General.Hostname + "-startup.sh"
			if err := tmpl.CreateFileFromTemplate("linux_startup.tmpl", agentCfg, file); err != nil {
				log.Fatal("generating linux command and control startup script: ", err)
			}
			file = startupDir + "/" + vm.General.Hostname + "-startup.service"
			if err := tmpl.CreateFileFromTemplate("linux-service.tmpl", agentCfg, file); err != nil {
				log.Fatal("generating linux command and control service script: ", err)
			}

		} else if vm.Hardware.OSType == v1.OSType_Windows {
			file := startupDir + "/" + vm.General.Hostname + "-startup.ps1"
			if err := tmpl.CreateFileFromTemplate("windows_startup.tmpl", agentCfg, file); err != nil {
				log.Fatal("generating windows command and control startup script: ", err)
			}
			file = startupDir + "/" + vm.General.Hostname + "-scheduler.cmd"
			if err := tmpl.CreateFileFromTemplate("windows-scheduler.tmpl", agentCfg, file); err != nil {
				log.Fatal("generating windows command and control service script: ", err)
			}
		}
	}

}

func postStart(spec v1.ExperimentSpec) error {
	return nil
}

func cleanup(spec v1.ExperimentSpec) error {
	return nil
}

func main() {
	logFile, err := os.Create("/tmp/ccDropperLog")
	defer logFile.Close()
	log.SetOutput(logFile)
	if err != nil { 
		log.Fatal("ccDropper: Can't create log file ... exiting")
	}

	var spec v1.ExperimentSpec
	mode := os.Args[1]
	var config DropperConfig

	//read in exp spec as json blob
	err = json.NewDecoder(os.Stdin).Decode(&spec)
	if err != nil {
		log.Fatal(err.Error())
	}
	//Get the application configuration data
	for _, e := range spec.Scenario.Apps.Experiment {
		if e.Name == NAME {
			log.Print("Found config")
			//log.Print(e.Metadata["generic"])
			//log.Print(e.Metadata["specific"])
			gg := ""
			for k,v := range e.Metadata["generic"].(map[string]interface{}) {
				switch v.(type) {
				case int:

				}
				gg += fmt.Sprintf("%s: \"%v\"\n",k,v)
			}
			log.Print(gg)
			cfg := AgentConfig{}
			err = yaml.Unmarshal([]byte(gg),&cfg)
			if err !=nil {
				log.Fatal(err)
			}
			log.Printf("%v",cfg)
			/*config.generic = cfg
			config.generic.agentPath = e.Metadata["generic"]["agent_path"]
			config.generic.autoStart = e.Metadata["generic"]["auto_start"]
			config.generic.agent = e.Metadata["generic"]["agent"]
			config.generic.agentArgs = e.Metadata["generic"]["agentArgs"]
			/*for _,spConfig := e.Metadata["specific"] {
				var hostCfg host
				host.hostname = spConfig["hostname"]
				host.cfg.agentPath = spConfig["agent_path"]
				host.cfg.agent = spConfig["agent"]
				host.cfg.autoStart = spConfig["auto_start"]
				host.cfg.agentArgs = spConfig["agent_args"]
				config.specific = append(config.specific, host)
			}
			*/
		}
	}
	log.Print(config)
	//computer the start directory where things will be generated
	startupDir := spec.BaseDir + "/startup"
	switch mode {
	case "configure":
		configure(&spec, config, startupDir)
	case "start":
		start(&spec, config, startupDir)
	case "postStart":
		postStart(spec)
	case "cleanup":
		cleanup(spec)
	}
	data, err := json.Marshal(spec)
	if err != nil {
		log.Fatal("ccDropper: marshaling experiment spec to JSON: %w", err)
	}
	fmt.Print(data)
	f, err := os.Create("/tmp/outJson")
	defer f.Close()
	f.Write(data)
	f.Sync()

}
